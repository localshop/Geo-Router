package Geo::Router::OSRM::Route;

use strict;
use warnings;

use JSON;
use Data::Dumper;
#use Geo::Point;
use Geo::Google::PolylineEncoder;


=head1 NAME

Geo::Route::OSRM::Route - Route Result object generated by OSRM

Access Open Street Map Routing REST Web Service API


=head1 VERSION

Version 0.0.4

=cut



=head1 SYNOPSIS

    use Geo::Router::OSRM;
    use Data::Dumper;


    my $osrm = Geo::Router::OSRM->new( );

    my $waypoints = [  [-27.919012,153.386215], [-27.936121,153.360809], [-28.033663, 153.434582]   ];

    if ( my $route = $osrm->viaroute( $waypoints )  )
    {
      print $route->geometry_encoded();   ## see OSRM::Route for docs
    }


=cut




#our $turn_instructions = {
#    NoTurn = 0, GoStraight, TurnSlightRight, TurnRight, TurnSharpRight, UTurn,
#    TurnSharpLeft, TurnLeft, TurnSlightLeft, ReachViaLocation, HeadOn, EnterRoundAbout,
#    LeaveRoundAbout, StayOnRoundAbout, StartAtEndOfStreet, ReachedYourDestination,
#    EnterAgainstAllowedDirection, LeaveAgainstAllowedDirection,
#    InverseAccessRestrictionFlag = 127,
#    AccessRestrictionFlag = 128,
#    AccessRestrictionPenalty = 129
#};



#    "status": 0,
#    "status_message": "Found route between points",
#    "route_geometry": "_lbw~A}}ijOzSe~@vMc_@eYe]qEcFaFoD}GqBmTqBgEyBuCiF{JeX_KgUyUq\\eo@ueA}G{MXqBc@iFuAkBv@}EbL}R|oBc}C",
#    "route_instructions":


#status
#0 - SUCCESSFUL
#207 - NO_ROUTE

#status_message
#Found route between points
#Cannot find route between points

#route_geometry


#route_summary

#route_name

#via_points

#hint_data

# ["instruction","streetname",length,position,time,"length","earth_direction",azimuth]





sub new
{

    my $class = shift;
    my (  $ahr ) = @_;


    my $self = bless

    {
      #  'start_desc'     => $ahr->{start_desc} || '',
      #  'finish_desc'    => $ahr->{finish_desc} || '',
        'route_summary'      => $ahr->{route_summary} || '',
        'route_geometry'     => $ahr->{route_geometry} || '',
        'geometry_encoded_google' => $ahr->{geometry_encoded_google} || '',
        'geometry_decoded'   => [],
        'route_instructions' => $ahr->{route_instructions} || [],
        'total_distance'     => $ahr->{total_distance} || 0,
        'total_duration'     => $ahr->{total_duration} || 0,
        'via_points'         => $ahr->{via_points}     || [],
        'formatted_instructions' => $ahr->{formatted_instructions} || [],



    }, $class;
    return $class->error("Cannot create $class without route_geometry hashkey parameter") unless $ahr->{route_geometry};

    return $self; ## get here if all values passed in as params ... could possibly include a check to sensure run_id is correct ... possibly option to create record
}




=head1 METHODS

=head2 summary_as_text()

  Returns a string with 3 lines descibing the end points, distance and duration.

  print $route->summary_as_text();

=cut

sub summary_as_text
{
    my ( $self ) = @_;
    my $sm = {
    };
    return qq{
        From: $self->{'route_summary'}{'start_point'} to $self->{'route_summary'}{'end_point'}
        Total Distance: $self->{total_distance} meters
        Total Duration: $self->{total_duration} seconds\n};
}


=head2 total_distance()

Returns the total distance of the route in meters.

  print $route->total_distance();

=cut

sub total_distance
{
    my ( $self ) = @_;
    return $self->{total_distance};
}


=head2 total_duration()

Returns the total duration of the route in seconds.

  print $route->total_duration();

=cut
sub total_duration
{
    my ( $self ) = @_;
    return $self->{total_duration};
}


=head2 geometry_encoded()

Returns the encoded geometry string returned by the service.

  print $route->geometry_encoded();

=cut
sub geometry_encoded
{
    my ( $self ) = @_;
    return $self->{route_geometry};
}


=head2 geometry_encoded_google()

Returns a string containing the encoded geometry of the route using Google Polyline encoding at a precision level suitable for inclusion on Google Maps.
Use this if you want to render as a Google Map Polyline.

NB: OSM lat/lng values need are divided by 10 to match the precision of Google Maps.

  print $route->geometry_encoded_google();

=cut
sub geometry_encoded_google
{
    my ( $self ) = @_;
    return $self->{geometry_encoded_google} if ( $self->{geometry_encoded_google} ne '');

    ## otherwise need to build up google encoded poly
    $self->geometry_decoded(); ## decode points if hasn't already been done.


    my $g = Geo::Google::PolylineEncoder->new();
    my $gpoints = [];
    foreach my $p ( @{$self->{geometry_decoded}} )
      {
        #print qq{$p->{lat}, $p->{lon}\n};
        push @$gpoints, {lat => $p->{lat}, lon => $p->{lon} };
      }
    $self->{geometry_encoded_google} = $g->encode($gpoints);

    return $self->{geometry_encoded_google};
}


=head2 geometry_decoded()

Returns an Array Ref of the points that make the route geometry. Each point is descibed by a hashref with lat and lon as the keys

    my $aref - $route->gemotry_decoded();
    foreach my $point ( @$aref )
    {
       print "$point->{lat}, $point->{lon}" . "\n";
    }

=cut


sub geometry_decoded
{
    my ( $self ) = @_;
    return $self->{geometry_decoded} if (@{$self->{geometry_decoded}}>0);

    my $g = Geo::Google::PolylineEncoder->new();
    $self->{geometry_decoded_raw} = $g->decode_points( $self->{route_geometry} );
    foreach my $p ( @{$self->{geometry_decoded_raw}} )
    {
        #print qq{$p->{lat}, $p->{lon}\n};
      push @{ $self->{geometry_decoded}} , {lat => $p->{lat}/10, lon => $p->{lon}/10 };
    }
    #print Dumper $self->{geometry_decoded};

    return $self->{geometry_decoded};

}


=head2 formatted_instructions()

Returns an array of hashrefs describing each step of the route.

  my $fi = $route->formatted_instructions();
  foreach my $step ( @$fi )
  {
    print qq{
      At point:     $step->{latlng][0], $step->{latlng][1]
      Instructions: $step->{desc}
      at Heading (degrees) : $step->{heading}
      at Heading (Radians) : Sstep->{heading_rad}
      at heading (Compass) : $step->{heading_comp}
      for distance         : $step->{distance}
      for duration         : $step->{duration}
      along streetname     : $step->{streetname}
    };
  }


=cut

sub formatted_instructions
{
    #  ["instruction","streetname",length,position,time,"length","earth_direction",azimuth]
    my ( $self ) = @_;

    return $self->{formatted_instructions} if ( @{$self->{formatted_instructions}} > 0 );

    $self->geometry_decoded();

    ## assertion: $self->{formatted_instructions} = []


    foreach my $step ( @{ $self->{route_instructions}} )
    {
        my $turn_off = '';
        if ( $step->[0] =~ /^11-(\d+)$/m)
        {
            $step->[0] = 11;
            $turn_off = " and take the " . ('first','second','third','fourth','fifth','sixth','seventh','eight','nineth','tenth')[$1] . ' exit';
        }
        my $drive = ('No Turn', 'Go Straight', 'Turn Slight Right', 'Turn Right', 'Turn Sharp Right', 'U Turn',
                     'Turn Sharp Left', 'Turn Left', 'Turn Slight Left', 'Reach Via Location', 'Head On', 'Enter Round About',
                     'Leave Round About', 'Stay On RoundAbout', 'Start At End Of Street',  'Reached Your Destination',
                      'Enter Against Allowed Direction', 'Leave Against Allowed Direction')[$step->[0]];
     #   print qq{ $drive ($step->[0]) '$step->[1]'  '$step->[2]' meters   <$self->{geometry_decoded}[$step->[3]]->{lat} ,  $self->{geometry_decoded}[$step->[3]]->{lon}> - $step->[4] - $step->[5] - $step->[6] - $step->[7] \n};
        push @{$self->{formatted_instructions}}, {
            descr        => qq{$drive$turn_off},
            latlng       => [  $self->{geometry_decoded}[$step->[3]]->{lat} ,  $self->{geometry_decoded}[$step->[3]]->{lon}  ],
            heading      => $step->[7],
            heading_rad  => $step->[7] * 0.0174532925,  ## aproximate conversion ration
            heading_comp => $step->[6],
            distance     => $step->[2],
            duration     => $step->[4],
            streetname   => $step->[1],
        };
        #my $rad = $step->[7] * 0.0175;
        #print qq{$step->[6]\t\t\t\t$step->[7] $rad\n};
    }
    return $self->{formatted_instructions};
}

############################################

sub error
{
    my ( $self, $msg) = @_;
    return $self->{error} if ( not defined $msg );
    $self->{error} .= "$msg";
    warn($msg) if $self->{DEBUG};
    return undef;
}

1;


=head1 TODO

=over

=item *include optional alternative results from viaroute - currently ignored

=back

=head1 REQUESTS AND BUGS

Please report any bugs or feature requests to Peter Scott, <pscott at shogundriver.com>

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Geo::Route::OSRM::Route
    perldoc Geo::Route::OSRM

You can also look for information at:

=over

=item * Project OSRM Page

L<http://project-osrm.org>

=item * OSRM Web Interface

L<http://http://map.project-osrm.org>

=back

=head1 SEE ALSO

L<http://wiki.openstreetmap.org/wiki/Nominatim>

L<http://open.mapquestapi.com/nominatim/>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2014-2016 Peter Scott <peter at pscott.com.au>, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=head1 AUTHOR

Peter Scott, <peter at pscott.com.au>

=cut
